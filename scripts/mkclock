#! /bin/sh

	version=002
	echo clock test generator version $version

	# V1.1
	#	- umask 003 added to allow users rw access to uut data
	
######################################################

	proc_find_sec_inputs()
		{
		#find input cells in secondary nets
		count_members_sec=0
		while IFS=" " read -a w_sec
			do
				device_sec[count_members_sec]=${w_sec[0]};	#set device to be processed for secondary net input search	
				line_of_atg_expect_sec=();
				while read -a line_of_atg_expect_sec
					do
				       	[ "${line_of_atg_expect_sec[2]}" = "secondary_net" -a "${line_of_atg_expect_sec[11]}" = "${line_of_atg_drive[3]}" -a "${line_of_atg_expect_sec[5]}" = "${device_sec[count_members_sec]}" ] &&
							{
            	            #echo ${line_of_atg_drive[3]} '->' ${line_of_atg_expect_sec[3]}
							exp_line_for_seq_file[count_members_sec]="${exp_line_for_seq_file[count_members_sec]} ${line_of_atg_expect_sec[9]}=${drv_line[id]}"
							}
					done < tmp/atg_expect.tmp
                count_members_sec=$[count_members_sec+1]; # prepare next device (for secondary input cell search) to be processed
			done < tmp/members.tmp
		}


	proc_fraction_udb()
		{
		#remove all comments from udb and write to tmp file
			while read v
				do
					echo $v | awk 'BEGIN { FS = "--" } ; { print $1 }' >> tmp/udb_no_comments.tmp;
				done < ${udb}
		
		#remove empty lines
			grep -v ^[[:space:]]*\$ tmp/udb_no_comments.tmp > tmp/udb_no_emptylines.tmp
		
		#read SPC section
			sed -n '/Section scanpath_configuration/,/EndSection/p' tmp/udb_no_emptylines.tmp > tmp/spc.tmp
		
			#read CHAIN section	#CS: How to handle multiple scan paths ?
				sed -n '/SubSection chain/,/EndSubSection/p' tmp/spc.tmp > tmp/chain.tmp
		
			#read chain members
				cat tmp/chain.tmp | grep -v Section > tmp/members.tmp
		
		#read registers section
			sed -n '/Section registers/,/EndSection/p' tmp/udb_no_emptylines.tmp > tmp/registers.tmp
		
		#read netlist section
			sed -n '/Section netlist/,/EndSection/p' tmp/udb_no_emptylines.tmp > $test_name/netlist.txt
			#cp tmp/udb_no_emptylines.tmp $test_name/database_copy.udb		
		}


	proc_write_options_section()
		{
		#read electrical parameters
		sed -n '/SubSection options/,/EndSubSection/p' tmp/spc.tmp > tmp/options.tmp
		while read -a op
			do
				[ "${op[0]}" = "SubSection" ] && echo Section options >> $test_name/$test_name.seq
				[ "${op[0]}" = "on_fail" ] && echo ' '${op[*]} >> $test_name/$test_name.seq
				[ "${op[0]}" = "frequency" ] && echo ' '${op[*]} >> $test_name/$test_name.seq
				[ "${op[0]}" = "trailer_ir" ] && echo ' '${op[*]} >> $test_name/$test_name.seq
				[ "${op[0]}" = "trailer_dr" ] && echo ' '${op[*]} >> $test_name/$test_name.seq
				[ "${op[0]}" = "voltage_out_port_1" ] && echo ' '${op[*]} >> $test_name/$test_name.seq
				[ "${op[0]}" = "voltage_out_port_2" ] && echo ' '${op[*]} >> $test_name/$test_name.seq
				[ "${op[0]}" = "tck_driver_port_1" ] && echo ' '${op[*]} >> $test_name/$test_name.seq
				[ "${op[0]}" = "tck_driver_port_2" ] && echo ' '${op[*]} >> $test_name/$test_name.seq
				[ "${op[0]}" = "tms_driver_port_1" ] && echo ' '${op[*]} >> $test_name/$test_name.seq
				[ "${op[0]}" = "tms_driver_port_2" ] && echo ' '${op[*]} >> $test_name/$test_name.seq
				[ "${op[0]}" = "tdo_driver_port_1" ] && echo ' '${op[*]} >> $test_name/$test_name.seq
				[ "${op[0]}" = "tdo_driver_port_2" ] && echo ' '${op[*]} >> $test_name/$test_name.seq
				[ "${op[0]}" = "trst_driver_port_1" ] && echo ' '${op[*]} >> $test_name/$test_name.seq
				[ "${op[0]}" = "trst_driver_port_2" ] && echo ' '${op[*]} >> $test_name/$test_name.seq
				[ "${op[0]}" = "threshold_tdi_port_1" ] && echo ' '${op[*]} >> $test_name/$test_name.seq
				[ "${op[0]}" = "threshold_tdi_port_2" ] && echo ' '${op[*]} >> $test_name/$test_name.seq
				[ "${op[0]}" = "EndSubSection" ] && echo EndSection >> $test_name/$test_name.seq
			done < tmp/options.tmp
		echo >> $test_name/$test_name.seq
		}


#####	BEGIN MAIN PROGRAM ####################################################################



#read UUT name and data base name in shell variables
	dir=`pwd`
	uut_name=`basename $dir`
#		echo UUT: $uut_name
	udb=$1;
#		echo 'data base   :' $udb
	test_name=$2
#		echo 'test name   :' $test_name
#		echo
	algorithm=$3
	target_device=$4
	target_pin=$5
	retry_count=$6
	retry_delay=$7

	umask 003 # ins V1.1

# clean up tmp directory
	touch tmp/dummy.tmp	#CS: try more elegant way !
	rm tmp/*.tmp
	
# remove old test directory and create a new one #CS: request user confirmation !
	rm -rf $test_name
	mkdir $test_name

	echo "Test description: write your info here ... " > $test_name/exe_desc.txt

	echo "Section info" >> $test_name/$test_name.seq
	echo ' created by clock test generator version' $version >> $test_name/$test_name.seq
	echo -n ' date      : ' >> $test_name/$test_name.seq
	date >> $test_name/$test_name.seq
	echo ' database  : '$udb >> $test_name/$test_name.seq
	echo " algorithm : "$algorithm >> $test_name/$test_name.seq
	echo "EndSection" >> $test_name/$test_name.seq
	echo >> $test_name/$test_name.seq

	proc_fraction_udb

	proc_write_options_section


	echo "Section sequence 1" >> $test_name/$test_name.seq

	cat setup/test_init_custom.txt >> $test_name/$test_name.seq # ins V2.4

	echo 'reading database ...'




#identify chain members
	count_members=0
	while IFS=" " read -a v
	do
			device[count_members]=${v[0]};
			#sed -n "/SubSection ${device[count_members]}/,/EndSubSection ${device[count_members]}/p" tmp/registers.tmp > tmp/${device[count_members]}_registers.tmp
			#not secure, try this
			sed -n "/\<SubSection ${device[count_members]}\>/,/\<EndSubSection ${device[count_members]}\>/p" tmp/registers.tmp > tmp/${device[count_members]}_registers.tmp
			count_members=$[count_members+1]; # increment array index on each chain member
	done < tmp/members.tmp



#################################################################################

#preset vector counter
	vector_ct=0


#safebit preloading
	echo ' -- set devices in sample/preload mode' >> $test_name/$test_name.seq
#write instructions in seq. file
	sample_found=no
	preload_found=no
	extest_found=no
	ir_length=0
	count_members=0
	while IFS=" " read -a v
	do
			device[count_members]=${v[0]};

			#write device name in sequence file
			echo -n ' set '${device[count_members]}' drv ir ' >> $test_name/$test_name.seq

			while read -a line_of_registers
			do
				#echo ${line_of_registers[*]}
				[ "${line_of_registers[0]}" = "instruction_register_length" ] && 
					{
					ir_length=$[line_of_registers[1]-1]
					echo -n $ir_length 'downto 0 = ' >> $test_name/$test_name.seq
					break
					}
			done < tmp/${device[count_members]}_registers.tmp

			sed -n '/SubSection instruction_opcodes/,/EndSubSection/p' tmp/${device[count_members]}_registers.tmp > tmp/${device[count_members]}_opcodes.tmp

			#search for sample instruction first
			while read -a line_of_opcodes_section
			do
				[ "${line_of_opcodes_section[0]}" = "sample" ] && 
					{
					sample_found=yes
					echo -n ${line_of_opcodes_section[1]} ${line_of_opcodes_section[0]} >> $test_name/$test_name.seq
					break
					}
			done < tmp/${device[count_members]}_opcodes.tmp

			#if no sample instructin found, search for preload instruction instead
			[ "$sample_found" = "no" ] &&
				{
				while read -a line_of_opcodes_section
				do
					[ "${line_of_opcodes_section[0]}" = "preload" ] && 
						{
						preload_found=yes
						echo -n ${line_of_opcodes_section[1]} ${line_of_opcodes_section[0]} >> $test_name/$test_name.seq
						break
						}
				done < tmp/${device[count_members]}_opcodes.tmp
				}

			#if no sample and no preload instructin found, cancel test generation
			[ "$sample_found" = "no" -a "$preload_found" = "no" ] &&
				{
				echo 'ERROR ! Device '${device[count_members]} neither supports SAMPLE nor PRELOAD mode !
				echo '        Non-intrusive test mode not possible !'
				exit 1
				}
				
			echo >> $test_name/$test_name.seq

			count_members=$[count_members+1]; # increment array index on each chain member
	done < tmp/members.tmp


#################################################################################

#write caputure IR values in seq file
	echo ' -- expect capture ir values' >> $test_name/$test_name.seq
	count_members=0
	while IFS=" " read -a v
	do
			device[count_members]=${v[0]};

			#write device name in sequence file
			echo -n ' set '${device[count_members]}' exp ir ' >> $test_name/$test_name.seq

			#write capture ir value in seq file
			while read -a line_of_registers
			do
				[ "${line_of_registers[0]}" = "instruction_capture" ] && 
					{
					echo -n $ir_length 'downto 0 = '${line_of_registers[1]} ${line_of_registers[0]} >> $test_name/$test_name.seq
					break
					}
			done < tmp/${device[count_members]}_registers.tmp

			echo >> $test_name/$test_name.seq

			count_members=$[count_members+1]; # increment array index on each chain member
	done < tmp/members.tmp

	vector_ct=$[vector_ct+1]; # increment vecor counter on each sir odr sdr
	echo ' sir id '$vector_ct >> $test_name/$test_name.seq
	echo >> $test_name/$test_name.seq


#################################################################################




#safebit preloading
#write safebits in seq. file
	echo ' -- safebits loading' >> $test_name/$test_name.seq
	count_members=0
	while IFS=" " read -a v
	do
			device[count_members]=${v[0]};

			#write device name in sequence file
			echo -n ' set '${device[count_members]}' drv boundary ' >> $test_name/$test_name.seq

			#write target register in seq file
			while read -a line_of_registers
			do
				[ "${line_of_registers[0]}" = "boundary_register_length" ] && 
					{
					echo -n $[line_of_registers[1]-1] 'downto 0 = ' >> $test_name/$test_name.seq
					break
					}
			done < tmp/${device[count_members]}_registers.tmp

			#write safebits in seq file
			sed -n '/SubSection safebits/,/EndSubSection/p' tmp/${device[count_members]}_registers.tmp > tmp/${device[count_members]}_safebits.tmp
			while read -a line_of_safebits
			do
				[ "${line_of_safebits[0]}" = "safebits" ] && 
					{
					echo -n ${line_of_safebits[1]} ${line_of_safebits[0]} >> $test_name/$test_name.seq
					break
					}
			done < tmp/${device[count_members]}_safebits.tmp


			echo >> $test_name/$test_name.seq

			count_members=$[count_members+1]; # increment array index on each chain member
	done < tmp/members.tmp




#write expect values in seq. file
	echo ' -- nothing meaningful to expect here' >> $test_name/$test_name.seq
	count_members=0
	while IFS=" " read -a v
	do
			device[count_members]=${v[0]};

			#write device name in sequence file
			echo -n ' set '${device[count_members]}' exp boundary ' >> $test_name/$test_name.seq

			#write target register in seq file
			while read -a line_of_registers
			do
				[ "${line_of_registers[0]}" = "boundary_register_length" ] && 
					{
					echo -n $[line_of_registers[1]-1] 'downto 0 = ' >> $test_name/$test_name.seq
					break
					}
			done < tmp/${device[count_members]}_registers.tmp

			#write safebits in seq file
			echo -n x >> $test_name/$test_name.seq
			echo >> $test_name/$test_name.seq

			count_members=$[count_members+1]; # increment array index on each chain member
	done < tmp/members.tmp

	vector_ct=$[vector_ct+1]; # increment vecor counter on each sir odr sdr
	echo ' sdr id '$vector_ct >> $test_name/$test_name.seq
	echo >> $test_name/$test_name.seq


#################################################################################

	echo " -- wait for H on target "$target_device" pin "$target_pin >> $test_name/$test_name.seq

	#collect all input cells
	sed -n '/Section atg_expect/,/EndSection/p' tmp/udb_no_emptylines.tmp > tmp/input_cells.tmp
	sed -n '/Section static_expect/,/EndSection/p' tmp/udb_no_emptylines.tmp >> tmp/input_cells.tmp
	sed -n '/Section input_cells_class_NA/,/EndSection/p' tmp/udb_no_emptylines.tmp >> tmp/input_cells.tmp

	#search device in input cell list
	target_in_input_cell_list=no;

	while read -a line_of_input_cells
	do
	    [ "${line_of_input_cells[5]}" = "$target_device" -a "${line_of_input_cells[7]}" = "$target_pin" ] &&
		{
		input_cell_number=${line_of_input_cells[9]}
		echo ' set '$target_device' exp boundary '$input_cell_number'=1' >> $test_name/$test_name.seq
		target_in_input_cell_list=yes;
		}
	done < tmp/input_cells.tmp

	[ "$target_in_input_cell_list" = "no" ] &&
		{
		echo 'ERROR : Target device '$target_device 'pin '$target_pin ' does not exist !'
		exit 1
		}

	vector_ct=$[vector_ct+1]; # increment vecor counter on each sir odr sdr
	echo ' sdr id '$vector_ct option retry $retry_count delay $retry_delay >> $test_name/$test_name.seq
	echo >> $test_name/$test_name.seq


	echo " -- wait for L on target "$target_device" pin "$target_pin >> $test_name/$test_name.seq

	echo ' set '$target_device' exp boundary '$input_cell_number'=0' >> $test_name/$test_name.seq
	vector_ct=$[vector_ct+1]; # increment vecor counter on each sir odr sdr
	echo ' sdr id '$vector_ct option retry $retry_count delay $retry_delay >> $test_name/$test_name.seq


	echo >> $test_name/$test_name.seq

	echo " trst" >> $test_name/$test_name.seq


	echo "EndSection" >> $test_name/$test_name.seq

	echo
exit
